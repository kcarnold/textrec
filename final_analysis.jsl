dt_all = Open(
	"/Users/kcarnold/code/textrec/data/analyzed/combined_data.csv",
	Charset( "utf-8" ),
	Import Settings(
		End Of Line( CRLF, CR, LF ),
		End Of Field( Comma, CSV( 1 ) ),
		Strip Quotes( 1 ),
		Use Apostrophe as Quotation Mark( 0 ),
		Use Regional Settings( 0 ),
		Scan Whole File( 0 ),
		Treat empty columns as numeric( 0 ),
		CompressNumericColumns( 0 ),
		CompressCharacterColumns( 0 ),
		CompressAllowListCheck( 0 ),
		Labels( 1 ),
		Column Names Start( 1 ),
		Data Starts( 2 ),
		Lines To Read( "All" ),
		Year Rule( "20xx" )
	)
);

// Master data filter
dt = Subset( dt_all, Rows( dt_all << get rows where( :experiment != "spec1" & :participant != "pr5hff" & :participant != "7q253f" ) ) );
Close( dt_all );
dt << Set Name( "Combined gc1+spec2" );


// Set data types
Column( dt, "stimulus" ) << Data Type( "Character" ) << Modeling Type( "Nominal" );
// "The last level is the level with the highest value order coding; it is the level whose indicator function is not included in the model." (https://www.jmp.com/support/help/14/indicator-parameterization-estimates.shtml)
Column( dt, "condition" ) << Set Property( "Value Ordering", {"gated", "contextual", "standard", "norecs"} );

// Transform columns
quartilify = {/*"NFC", "Extraversion", "Openness", "Trust",*/ "chars_per_sec_norecs_mean"};
For( i = 1, i <= N Items( quartilify ), i++,
	dt << /*New Column( quartilify[i] || " Quartile",
		Ordinal,
		Formula( 1 + Floor( (4 * (Col Rank( Column( quartilify[i] ), <<tie( "average" ) ) - 1)) / N Row() ) )
	)*/	<<New Column( quartilify[i] || " Tertile",
		Ordinal,
		Formula( 1 + Floor( (3 * (Col Rank( Column( quartilify[i] ), <<tie( "average" ) ) - 1)) / N Row() ) )
	)
);

dt << New Column( "chars_per_sec_log", Numeric, Formula( Log( :characters_per_sec ) ) );
dt << New Column( "chars_per_sec_norecs_log", Numeric, Formula( Log( :chars_per_sec_norecs_mean ) ) );


dt << New Column( "mintaps_standard", Numeric, Formula( :corrected_tapstotype_standard / :num_words ) );
dt << New Column( "mintaps_contextual", Numeric, Formula( :corrected_tapstotype_contextual / :num_words ) );
dt << New Column( "mintaps_std_minus_contextual", Numeric, Formula( mintaps_standard - mintaps_contextual ) );

dt << New Column( "num_details_auto", Numeric, Formula( :pos_count_ADJ + :pos_count_NUM + :pos_count_NOUN + :pos_count_VERB ) );

New Window( "Manipulation Checks",
	dt << Matched Pairs(
		X( :condition ),
		Y( :mintaps_standard, :mintaps_contextual),
		Plot Dif By Row( 1 ),
		Reference Frame( 0 ),
		Wilcoxon Signed Rank( 1 )
	)
);

Arg(Expr(Effects( :experiment, :condition, :idx )), 2)
Parse("Effects( :experiment, :condition, :idx, " || "" || ")")

// Main analysis function
analyze = Function( {response_name, window_title},
	{response_str="Response " || response_name},
	Show(Eval List({response_str}));
	(dt << Fit Model(
		Y( As Name( response_name ) ),
		Effects( :experiment, :condition, :idx ),
		Random Effects( :participant, :participant * :condition, :stimulus ),
		NoBounds( 1 ),
		Personality( "Standard Least Squares" ),
		Method( "REML" ),
		Emphasis( "Minimal Report" ),
		Run(
			As Name( response_name ) << {Summary of Fit( 1 ), Analysis of Variance( 0 ), Parameter Estimates( 1 ), Lack of Fit( 0 ),
			Show Prediction Expression( 1 ), Plot Actual by Predicted( 0 ), Plot Regression( 0 ), Plot Residual by Predicted( 0 ),
			Plot Studentized Residuals( 0 ), Plot Effect Leverage( 0 ), Show All Confidence Intervals( 1 ), {:condition << {LSMeans Tukey HSD( 0.05 )
			}}}
		),
		SendToReport( Dispatch( response_str, "Effect Details", OutlineBox, {Close( 0 )} ) )
	)) << Set Window Title( window_title );
);


/* Outcome Effects */
gb = dt << Graph Builder(
	Variables( X( :condition ), Y( :mintaps_standard ) ),
	Elements( Bar( X, Y, Legend( 4 ), Error Bars( "Standard Error" ), Label( "Label by Value" ) ) ),
	SendToReport(
		Dispatch( {}, "Graph Builder", OutlineBox, {Set Title( "Ideal Taps per Typo-Corrected Word" )} ),
		Dispatch( {}, "graph title", TextEditBox, {Set Text( "" )} ),
		Dispatch( {}, "X title", TextEditBox, {Set Text( "Condition" )} ),
		Dispatch( {}, "Y title", TextEditBox, {Set Text( "Ideal Taps per Typo-Corrected Word" )} )
	)
);

analyze( "mintaps_standard", "Ideal Taps per Corrected Word" );
analyze( "mintaps_std_minus_contextual", "Outcome difference between systems" );


/** Process Effects */

analyze( "chars_per_sec_log", "Characters per Second" );
analyze( "backspaces_per_char", "backspaces per char" );

/** Rec usage */

analyze("rec_use_per_word", "Rec Usage Per Word");
analyze("relevant_use_frac", "Relevant Rec Use");



///////////


(dt << Graph Builder(
	Variables( X( :condition ), Y( :chars_per_sec_ratio_to_norecs ), Overlay( :chars_per_sec_norecs_mean Tertile ) ),
	Where( :condition != "norecs" ),
	Elements( Bar( X, Y, Legend( 10 ), Error Bars( "Standard Error" ) ) ),
	SendToReport( Dispatch( {}, "chars_per_sec_ratio_to_norecs", ScaleBox, {Add Ref Line( 1, "Solid", "Black", "", 1 )} ) )
)) << set window title( "speed ratio to norecs" );

(dt << Graph Builder(
	Variables(
		X( :condition ),
		Y( Transform Column( "chars_per_sec_log-chars_per_sec_norecs_log", Formula( :chars_per_sec_log - :chars_per_sec_norecs_log ) ) ),
		Overlay( :chars_per_sec_norecs_mean Tertile )
	),
	Elements( Bar( X, Y, Legend( 17 ), Error Bars( "Standard Error" ) ) ),
	Where( :condition != "norecs" )
)) << set window tytle( "speed ratio to norecs log" );



(dt << Fit Model(
	Y( :chars_per_sec_ratio_to_norecs ),
	Where( :condition != "norecs" ),
	Effects(
		:condition,
		:idx,
		:chars_per_sec_norecs_mean,
		:chars_per_sec_norecs_mean * :condition, 

	),
	Random Effects( :participant, :participant * :condition, :stimulus ),
	NoBounds( 1 ),
	Personality( "Standard Least Squares" ),
	Method( "REML" ),
	Emphasis( "Minimal Report" ),
	Run(
		:chars_per_sec_ratio_to_norecs << {Summary of Fit( 1 ), Analysis of Variance( 0 ), Parameter Estimates( 1 ), Lack of Fit( 0 ),
		Show Prediction Expression( 1 ), Plot Actual by Predicted( 0 ), Plot Regression( 0 ), Plot Residual by Predicted( 0 ),
		Plot Studentized Residuals( 0 ), Plot Effect Leverage( 0 ), Show All Confidence Intervals( 1 )}
	)
)) << Set window title( "speed interaction" );

(dt << Fit Model(
	Y( :chars_per_sec_log ),
	Where( :condition != "norecs" ),
	Effects(
		:condition,
		:idx,
		:chars_per_sec_norecs_log//,
		//		:chars_per_sec_norecs_log * :condition, 

	),
	Random Effects( :participant, :participant * :condition, :stimulus ),
	NoBounds( 1 ),
	Personality( "Standard Least Squares" ),
	Method( "REML" ),
	Emphasis( "Minimal Report" ),
	Run(
		:characters_per_sec << {Summary of Fit( 1 ), Analysis of Variance( 0 ), Parameter Estimates( 1 ), Lack of Fit( 0 ),
		Show Prediction Expression( 1 ), Plot Actual by Predicted( 0 ), Plot Regression( 0 ), Plot Residual by Predicted( 0 ),
		Plot Studentized Residuals( 0 ), Plot Effect Leverage( 0 ), Show All Confidence Intervals( 1 )}
	)
)) << Set window title( "simple speed interaction" );


/** Unclear how to interpret this one:
(dt << Fit Model(
	By( :chars_per_sec_norecs_mean Tertile ),
	Y( :chars_per_sec_log),
	Where( :experiment == "gc1" & :condition != "norecs" ),
	Effects( :condition, :idx, :chars_per_sec_norecs_log ),
	Random Effects( :participant, :participant * :condition, :stimulus ),
	Personality( "Standard Least Squares" ),
	Emphasis( "Minimal Report" ),
	Method( "REML" ),
	Run()
));
*/

dt << Fit Model(
	Y( Transform Column( "chars_per_sec_log-chars_per_sec_norecs_log", Formula( :chars_per_sec_log - :chars_per_sec_norecs_log ) ) ),
	Effects( :chars_per_sec_norecs_log, :condition, :idx, :chars_per_sec_norecs_log * :condition ),
	Random Effects( :participant, :participant * :condition, :stimulus ),
	NoBounds( 1 ),
	Personality( "Standard Least Squares" ),
	Method( "REML" ),
	Emphasis( "Minimal Report" ),
	Run(
		:Name( "chars_per_sec_log-chars_per_sec_norecs_log" ) << {Summary of Fit( 1 ), Analysis of Variance( 0 ), Parameter Estimates( 1 ),
		Lack of Fit( 0 ), Show Prediction Expression( 1 ), Plot Actual by Predicted( 0 ), Plot Regression( 0 ), Plot Residual by Predicted( 0 ),
		Plot Studentized Residuals( 0 ), Plot Effect Leverage( 0 ), Show All Confidence Intervals( 1 )}
	)
);
